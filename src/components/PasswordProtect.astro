---
import { generatePasswordData, obfuscateContent } from '@utils/contentProtect';

export interface Props {
  password: string;
  articleId: string;
  content: string;
}

const { password, articleId, content } = Astro.props;
const { token, salt } = generatePasswordData(password);
const obfuscatedContent = obfuscateContent(content, password);
---

<div class="password-protect-wrapper" data-article-id={articleId}>
  <div id={`password-container-${articleId}`} class="password-protect">
    <div class="lock-icon">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="5" y="11" width="14" height="10" rx="2" ry="2"></rect>
        <path d="M7 11V7a5 5 0 0110 0v4"></path>
      </svg>
    </div>
    <h3>此文章需要密码访问</h3>
    <input 
      type="password" 
      id={`password-input-${articleId}`}
      placeholder="请输入密码" 
      class="password-input"
      autocomplete="off"
    />
    <button 
      id={`unlock-btn-${articleId}`}
      class="unlock-btn"
      data-token={token}
      data-salt={salt}
      data-article-id={articleId}
    >
      解锁
    </button>
    <p id={`error-msg-${articleId}`} class="error-msg" style="display: none;">密码错误，请重试</p>
  </div>

  <!-- 存储加密后的内容 -->
  <div 
    id={`article-content-${articleId}`} 
    class="encrypted-content"
    style="display: none;"
    data-content={obfuscatedContent}
  >
  </div>
</div>

<style>
  .password-protect {
    text-align: center;
    padding: 4rem 2rem;
    border: 1px solid var(--color-border);
    border-radius: 8px;
    background: var(--color-bg-card);
    margin: 2rem 0;
  }

  .lock-icon {
    color: var(--color-text-50);
    margin-bottom: 1rem;
  }

  .password-input {
    margin: 1rem 0;
    padding: 0.5rem 1rem;
    border: 1px solid var(--color-border);
    border-radius: 4px;
    width: 200px;
    background: var(--color-bg-base);
    color: var(--color-text);
  }

  .unlock-btn {
    padding: 0.5rem 1.5rem;
    background: hsl(var(--hue), 70%, 55%);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: opacity 0.2s;
  }

  .unlock-btn:hover {
    opacity: 0.9;
  }

  .error-msg {
    color: #ef4444;
    margin-top: 0.5rem;
    font-size: 0.875rem;
  }

  .encrypted-content {
    animation: fadeIn 0.3s ease-in;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }
  
  .shake {
    animation: shake 0.5s;
  }
</style>

<script>
  // 动态导入crypto-client模块
  async function loadCryptoUtils() {
    const module = await import('@utils/crypto-client');
    return module;
  }

  // 将解密逻辑注册为全局函数，以便swup切换页面后可以重新初始化
  window.initPasswordProtect = async function() {
    const cryptoUtils = await loadCryptoUtils();
    
    const unlockButtons = document.querySelectorAll('.unlock-btn');
    
    unlockButtons.forEach(btn => {
      // 先移除旧的监听器
      btn.removeEventListener('click', handleUnlock);
      // 添加新的监听器
      btn.addEventListener('click', handleUnlock);
    });

    // 检查sessionStorage中是否已解锁
    checkUnlockedArticles();

    // 添加回车键支持
    document.querySelectorAll('.password-input').forEach(input => {
      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          const articleId = input.id.replace('password-input-', '');
          const btn = document.getElementById(`unlock-btn-${articleId}`);
          if (btn) btn.click();
        }
      });
    });
  }

  async function handleUnlock(e) {
    const btn = e.target;
    const articleId = btn.dataset.articleId;
    const storedToken = btn.dataset.token;
    const storedSalt = btn.dataset.salt;
    const inputEl = document.getElementById(`password-input-${articleId}`);
    const errorMsg = document.getElementById(`error-msg-${articleId}`);
    const inputPassword = inputEl.value;
    
    try {
      const cryptoUtils = await loadCryptoUtils();
      
      // 使用动态salt验证密码
      if (cryptoUtils.verifyPassword(inputPassword, storedToken, storedSalt)) {
        // 密码正确
        errorMsg.style.display = 'none';
        
        // 创建安全的密码处理器来管理会话
        const handler = new cryptoUtils.SecurePasswordHandler(articleId);
        handler.saveSession(inputPassword);
        
        // 显示文章内容
        await showArticleContent(articleId, inputPassword);
      } else {
        // 密码错误
        showError(errorMsg, inputEl);
      }
    } catch (error) {
      console.error('解锁失败:', error);
      showError(errorMsg, inputEl);
    }
  }

  function showError(errorMsg, inputEl) {
    errorMsg.style.display = 'block';
    inputEl.value = '';
    inputEl.classList.add('shake');
    setTimeout(() => inputEl.classList.remove('shake'), 500);
  }

  async function checkUnlockedArticles() {
    const cryptoUtils = await loadCryptoUtils();
    
    // 查找所有密码保护的文章
    const protectedArticles = document.querySelectorAll('.password-protect-wrapper');
    
    for (const wrapper of protectedArticles) {
      const articleId = wrapper.dataset.articleId;
      const handler = new cryptoUtils.SecurePasswordHandler(articleId);
      
      if (handler.hasValidSession()) {
        try {
          const password = await handler.getPassword();
          if (password) {
            await showArticleContent(articleId, password);
          }
        } catch (error) {
          console.error('恢复会话失败:', error);
          handler.clearSession();
        }
      }
    }
  }

  async function showArticleContent(articleId, password) {
    const container = document.getElementById(`password-container-${articleId}`);
    const contentEl = document.getElementById(`article-content-${articleId}`);
    
    if (container && contentEl) {
      try {
        const cryptoUtils = await loadCryptoUtils();
        
        // 获取并解密内容
        const obfuscatedContent = contentEl.dataset.content;
        const content = await cryptoUtils.decryptContent(obfuscatedContent, password);
        
        // 显示内容
        container.style.display = 'none';
        contentEl.innerHTML = content;
        contentEl.style.display = 'block';
        
        // 清除data属性中的内容（安全考虑）
        delete contentEl.dataset.content;
      } catch (error) {
        console.error('解密内容失败:', error);
        // 如果解密失败，清除会话
        const cryptoUtils = await loadCryptoUtils();
        const handler = new cryptoUtils.SecurePasswordHandler(articleId);
        handler.clearSession();
      }
    }
  }

  // 初始化
  document.addEventListener('DOMContentLoaded', async () => {
    if (window.initPasswordProtect) {
      await window.initPasswordProtect();
    }
  });

  // 支持swup页面切换
  if (window.swup) {
    window.swup.on('contentReplaced', async () => {
      if (window.initPasswordProtect) {
        await window.initPasswordProtect();
      }
    });
  }
</script>
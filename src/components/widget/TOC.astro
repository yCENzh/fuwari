---
import type { MarkdownHeading } from "astro";
import { siteConfig } from "../../config";

interface Props {
  class?: string;
  headings: MarkdownHeading[];
}

// 解构 Astro.props 并设置默认值
const { headings = [], class: className = "" } = Astro.props;
const { depth: maxLevel = 3 } = siteConfig.toc;

// 计算最小深度
const minDepth = Math.min(...headings.map(h => h.depth), 10);

// 检查是否在文章路由
const isPostsRoute = Astro.url.pathname.startsWith("/posts/");

// 移除标题末尾的 # 符号
const removeTailingHash = (text: string) => {
  const lastIndexOfHash = text.lastIndexOf("#");
  return lastIndexOfHash === text.length - 1 
    ? text.substring(0, lastIndexOfHash) 
    : text;
};

// 统计一级标题数量
let heading1Count = 1;
---
{isPostsRoute && headings.length > 0 && (
  <table-of-contents class:list={[className, "toc-container"]}>
    <div id="toc-inner-wrapper" class="toc-inner">
      {headings
        .filter(heading => heading.depth < minDepth + maxLevel)
        .map((heading) => {
          const level = heading.depth - minDepth;
          
          return (
            <a 
              href={`#${heading.slug}`}
              class={`toc-item level-${level}`}
              data-level={level}
            >
              {/* 层级指示器 */}
              <div class="toc-indicator">
                {level === 0 && (
                  <span class="toc-number">{heading1Count++}</span>
                )}
                {level === 1 && <span class="toc-dot"></span>}
                {level === 2 && <span class="toc-small-dot"></span>}
              </div>
              
              {/* 标题文本 */}
              <span class="toc-text">{removeTailingHash(heading.text)}</span>
            </a>
          );
        })}
    </div>
    
    {/* 激活指示器 */}
    <div 
      id="active-indicator" 
      class="toc-active-indicator"
      aria-hidden="true"
    ></div>
  </table-of-contents>
)}

<style>
  /* 目录容器样式 */
  .toc-container {
    position: relative;
    display: block;
  }
  
  /* 内部包装 */
  .toc-inner {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }
  
  /* 目录项通用样式 */
  .toc-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    border-radius: 0.75rem;
    transition: all 0.25s ease;
    text-decoration: none;
    color: var(--text-50);
    position: relative;
    z-index: 2;
    
    &:hover {
      background: var(--toc-btn-hover);
      color: var(--text-75);
    }
    
    &:active {
      background: var(--toc-btn-active);
    }
  }
  
  /* 层级样式 */
  .level-1 { padding-left: 1.5rem; }
  .level-2 { padding-left: 3rem; }
  
  /* 指示器样式 */
  .toc-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.25rem;
    height: 1.25rem;
    flex-shrink: 0;
  }
  
  .toc-number {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.375rem;
    background: var(--toc-badge-bg);
    color: var(--btn-content);
    font-size: 0.75rem;
    font-weight: 700;
    transition: all 0.25s ease;
  }
  
  .toc-dot {
    width: 0.5rem;
    height: 0.5rem;
    border-radius: 0.125rem;
    background: var(--toc-badge-bg);
    transition: all 0.25s ease;
  }
  
  .toc-small-dot {
    width: 0.375rem;
    height: 0.375rem;
    border-radius: 1px;
    background: var(--text-30);
    transition: all 0.25s ease;
  }
  
  /* 文本样式 */
  .toc-text {
    font-size: 0.875rem;
    transition: color 0.25s ease;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  
  /* 激活项样式 */
  .toc-item.visible {
    color: var(--primary);
    
    .toc-number {
      background: var(--primary);
      color: white;
    }
    
    .toc-dot {
      background: var(--primary);
      transform: scale(1.25);
    }
    
    .toc-small-dot {
      background: var(--primary);
      transform: scale(1.5);
    }
    
    .toc-text {
      color: var(--primary);
      font-weight: 500;
    }
  }
  
  /* 激活指示器 */
  .toc-active-indicator {
    position: absolute;
    left: 0;
    right: 0;
    border-radius: 0.75rem;
    background: var(--toc-btn-hover);
    z-index: 0;
    transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    border: 2px solid var(--toc-btn-hover);
    
    .toc-container:hover & {
      background: transparent;
      border-color: var(--toc-btn-active);
      border-style: dashed;
    }
  }
</style>

<script>
class TableOfContents extends HTMLElement {
  // 元素引用
  tocEl = null;
  activeIndicator = null;
  
  // 状态变量
  tocEntries = [];
  sections = [];
  headings = [];
  active = [];
  headingIdxMap = new Map();
  
  // 配置
  observer = null;
  visibleClass = "visible";
  rafId = null;
  lastActiveRange = [-1, -1];
  
  constructor() {
    super();
    
    // 使用更现代的 IntersectionObserver API
    this.observer = new IntersectionObserver(
      entries => this.handleIntersections(entries),
      { 
        rootMargin: "-20% 0px -70% 0px", 
        threshold: 0 
      }
    );
  }

  connectedCallback() {
    this.initElements();
    this.setupEventListeners();
    this.observeSections();
  }

  disconnectedCallback() {
    this.cleanup();
  }
  
  /**
   * 初始化DOM元素引用
   */
  initElements() {
    this.tocEl = this.querySelector("#toc-inner-wrapper");
    this.activeIndicator = this.querySelector("#active-indicator");
    this.tocEntries = Array.from(this.querySelectorAll(".toc-item"));
    
    // 初始化索引映射
    this.tocEntries.forEach((entry, index) => {
      const href = entry.getAttribute("href");
      if (href) {
        const id = decodeURIComponent(href.substring(1));
        this.headingIdxMap.set(id, index);
      }
    });
    
    // 初始化激活状态数组
    this.active = new Array(this.tocEntries.length).fill(false);
  }
  
  /**
   * 设置事件监听器
   */
  setupEventListeners() {
    if (this.tocEl) {
      this.tocEl.addEventListener("click", this.handleAnchorClick);
    }
  }
  
  /**
   * 开始观察章节元素
   */
  observeSections() {
    // 获取所有标题元素
    this.headings = Array.from(
      document.querySelectorAll(
        this.tocEntries.map(entry => {
          const href = entry.getAttribute("href");
          return href ? `[id="${decodeURIComponent(href.substring(1))}"]` : null;
        }).filter(Boolean)
      )
    );
    
    // 获取章节元素（通常是标题的父元素）
    this.sections = this.headings.map(heading => 
      heading.closest("section, div, article") || heading.parentElement
    );
    
    // 开始观察
    this.sections.forEach(section => {
      if (section) this.observer.observe(section);
    });
    
    // 初始更新
    this.updateActiveState();
  }
  
  /**
   * 处理IntersectionObserver回调
   */
  handleIntersections(entries) {
    entries.forEach(entry => {
      const id = entry.target.querySelector("h1, h2, h3, h4, h5, h6")?.id;
      if (!id) return;
      
      const index = this.headingIdxMap.get(id);
      if (index !== undefined) {
        this.active[index] = entry.isIntersecting;
      }
    });
    
    this.updateActiveState();
  }
  
  /**
   * 更新激活状态
   */
  updateActiveState() {
    // 使用requestAnimationFrame优化性能
    cancelAnimationFrame(this.rafId);
    this.rafId = requestAnimationFrame(() => {
      // 查找激活的标题范围
      let startIdx = -1;
      let endIdx = -1;
      
      // 查找第一个激活的标题
      for (let i = 0; i < this.active.length; i++) {
        if (this.active[i]) {
          startIdx = i;
          break;
        }
      }
      
      // 查找最后一个激活的标题
      if (startIdx !== -1) {
        for (let i = startIdx; i < this.active.length; i++) {
          if (this.active[i]) {
            endIdx = i;
          } else {
            break;
          }
        }
      }
      
      // 如果没有激活的标题，使用回退逻辑
      if (startIdx === -1) {
        this.fallbackToNearest();
        return;
      }
      
      // 更新UI
      this.updateVisualState(startIdx, endIdx);
    });
  }
  
  /**
   * 回退逻辑：找到最近的标题
   */
  fallbackToNearest() {
    // 实现简化版的回退逻辑
    const scrollPosition = window.scrollY + window.innerHeight / 3;
    
    for (let i = this.sections.length - 1; i >= 0; i--) {
      const rect = this.sections[i].getBoundingClientRect();
      const top = rect.top + window.scrollY;
      
      if (top < scrollPosition) {
        this.active.fill(false);
        this.active[i] = true;
        this.updateVisualState(i, i);
        break;
      }
    }
  }
  
  /**
   * 更新视觉状态
   */
  updateVisualState(startIdx, endIdx) {
    // 如果激活范围没有变化，则跳过更新
    if (this.lastActiveRange[0] === startIdx && this.lastActiveRange[1] === endIdx) {
      return;
    }
    
    this.lastActiveRange = [startIdx, endIdx];
    
    // 更新激活的TOC项
    this.tocEntries.forEach((entry, index) => {
      const isActive = index >= startIdx && index <= endIdx;
      entry.classList.toggle(this.visibleClass, isActive);
    });
    
    // 更新激活指示器
    this.updateActiveIndicator(startIdx, endIdx);
    
    // 滚动到可见位置
    this.scrollToVisibleItem(startIdx, endIdx);
  }
  
  /**
   * 更新激活指示器位置
   */
  updateActiveIndicator(startIdx, endIdx) {
    if (!this.activeIndicator || startIdx === -1 || endIdx === -1) return;
    
    const firstActive = this.tocEntries[startIdx];
    const lastActive = this.tocEntries[endIdx];
    
    if (!firstActive || !lastActive) return;
    
    const firstRect = firstActive.getBoundingClientRect();
    const lastRect = lastActive.getBoundingClientRect();
    const containerRect = this.getBoundingClientRect();
    
    const top = firstRect.top - containerRect.top;
    const height = lastRect.bottom - firstRect.top;
    
    // 使用transform实现更流畅的动画
    this.activeIndicator.style.transform = `translateY(${top}px)`;
    this.activeIndicator.style.height = `${height}px`;
  }
  
  /**
   * 滚动到可见的TOC项
   */
  scrollToVisibleItem(startIdx, endIdx) {
    if (!this.tocEl || startIdx === -1) return;
    
    const activeItem = this.tocEntries[startIdx];
    if (!activeItem) return;
    
    const itemRect = activeItem.getBoundingClientRect();
    const containerRect = this.tocEl.getBoundingClientRect();
    
    // 检查是否在可视区域内
    const isAbove = itemRect.top < containerRect.top;
    const isBelow = itemRect.bottom > containerRect.bottom;
    
    if (isAbove || isBelow) {
      // 计算滚动位置
      const scrollTop = this.tocEl.scrollTop;
      const targetPosition = activeItem.offsetTop - containerRect.height * 0.3;
      
      // 使用平滑滚动
      this.tocEl.scrollTo({
        top: targetPosition,
        behavior: "smooth"
      });
    }
  }
  
  /**
   * 处理锚点点击
   */
  handleAnchorClick = (event) => {
    // 查找被点击的锚点元素
    const anchor = event.target.closest("a");
    if (!anchor) return;
    
    // 防止默认行为，使用自定义滚动
    event.preventDefault();
    
    const href = anchor.getAttribute("href");
    if (!href || !href.startsWith("#")) return;
    
    const id = decodeURIComponent(href.substring(1));
    const heading = document.getElementById(id);
    
    if (heading) {
      // 平滑滚动到标题位置
      heading.scrollIntoView({
        behavior: "smooth",
        block: "start"
      });
      
      // 更新URL哈希（无页面跳转）
      history.replaceState(null, "", `#${id}`);
    }
  };
  
  /**
   * 清理资源
   */
  cleanup() {
    if (this.observer) {
      this.observer.disconnect();
    }
    
    if (this.tocEl) {
      this.tocEl.removeEventListener("click", this.handleAnchorClick);
    }
    
    cancelAnimationFrame(this.rafId);
  }
}

// 注册自定义元素
if (!customElements.get("table-of-contents")) {
  customElements.define("table-of-contents", TableOfContents);
}
</script>
